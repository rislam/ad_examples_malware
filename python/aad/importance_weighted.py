from sklearn.ensemble import RandomForestClassifier

from common.utils import *
from aad.aad_globals import *
from aad.aad_support import *

from aad.data_stream import *
from aad.malware_aad import MalwareDataStream
from aad.classifier_trees import RandomForestAadWrapper
from common.data_plotter import *

from sklearn.metrics import accuracy_score, f1_score, confusion_matrix
from libtlda.iw import ImportanceWeightedClassifier
import warnings
warnings.filterwarnings('ignore')


"""
pythonw -m aad.test_concept_drift_malware   
"""


def get_debug_args(dataset="", kl_alpha=0.05, detector_type=AAD_IFOREST):
    return ["--dataset=%s" % dataset,
            "--datafile=../datasets/anomaly/%s/fullsamples/%s_1.csv" % (dataset, dataset),
            "--startcol=2", "--labelindex=1", "--header",
            "--resultsdir=./temp", "--randseed=42",
            "--reruns=1",
            "--detector_type=%d" % detector_type,
            "--forest_score_type=%d" %
            (IFOR_SCORE_TYPE_NEG_PATH_LEN if detector_type == AAD_IFOREST
             else HST_LOG_SCORE_TYPE if detector_type == AAD_HSTREES
             else RSF_SCORE_TYPE if detector_type == AAD_RSFOREST else 0),
            "--init=%d" % INIT_UNIF,
            "--withprior", "--unifprior",  # use an (adaptive) uniform prior
            # ensure that scores of labeled anomalies are higher than tau-ranked instance,
            # while scores of nominals are lower
            "--constrainttype=%d" % AAD_CONSTRAINT_TAU_INSTANCE,
            # normalize is NOT required in general.
            # Especially, NEVER normalize if detector_type is anything other than AAD_IFOREST
            # "--norm_unit",
            "--forest_n_trees=100", "--forest_n_samples=256",
            "--forest_max_depth=%d" % (100 if detector_type == AAD_IFOREST else 7),
            "--forest_add_leaf_nodes_only",
            "--ensemble_score=%d" % ENSEMBLE_SCORE_LINEAR,
            "--describe_n_top=5",
            "--kl_alpha=%f" % kl_alpha,
            "--resultsdir=./temp",
            "--log_file=./temp/test_concept_drift_malware.log",
            "--debug"]


def test_concept_drift_in_malware():
    logger = logging.getLogger(__name__)

    args = get_aad_command_args(debug=True, debug_args=get_debug_args(dataset="Adadroid"))
    configure_logger(args)

    opts = AadOpts(args)

    np.random.seed(opts.randseed)
    X_full, y_full = read_data_as_matrix(opts)
    drop_empty_columns = True
    normalization = False
    if drop_empty_columns:
        logger.debug("Before dropping empty columns %d", X_full.shape[1])
        X_full = pd.DataFrame(X_full)
        X_full = X_full.loc[:, (X_full != 0).any(axis=0)]
        X_full = X_full.values
        logger.debug("After dropping empty columns %d", X_full.shape[1])
    stream = MalwareDataStream(X_full, y_full, IdServer(initial=0))
    logger.debug("Dataset loaded (%s): %s" % (opts.dataset, str(X_full.shape)))

    training_set = stream.read_next_from_stream(normalized=normalization)
    b_x, b_y = training_set.x, training_set.y
    print("x, y: (%d %d)" %(b_x.shape[0], b_y.shape[0]))
    window = 0
    uw_clf = RandomForestClassifier(n_estimators=100, random_state=42)
    uw_clf.fit(b_x, b_y)
    while not stream.empty():
        stream_window = stream.read_next_from_stream(normalized=normalization)
        x, y = stream_window.x, stream_window.y
        print("x, y: (%d %d)" % (x.shape[0], y.shape[0]))
        # clf_kmm = ImportanceWeightedClassifier(iwe='kmm')
        # clf_kmm.fit(b_x, b_y, x)
        # predictions = clf_kmm.predict(x)
        # print("F1 score weighted (KMM):   %f" %(f1_score(y, predictions, average='macro')))

        print("F1 score unweighted(RF): %f" % (f1_score(y, uw_clf.predict(x), average='macro')))

        clf_kde = ImportanceWeightedClassifier(iwe='lr')
        clf_kde.fit(b_x, b_y, x)
        predictions = clf_kde.predict(x)
        print("F1 score weighted (LR):   %f" % (f1_score(y, predictions, average='macro')))

        clf_nn = ImportanceWeightedClassifier(iwe='nn')
        clf_nn.fit(b_x, b_y, x)
        predictions = clf_nn.predict(x)
        print("F1 score weighted (KNN):   %f" % (f1_score(y, predictions, average='macro')))


if __name__ == "__main__":
    test_concept_drift_in_malware()
